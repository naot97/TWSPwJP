# -*- coding: utf-8 -*-
"""TWSPwJP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fBJvZvCaQWloMcdcDWQgm77_BHTKnnCk
"""

import cvxpy as cp
import numpy as np
import json
import time
import os
import pandas as pd
import math


json_path = './dataset/DS0/input1.json'

#Read input
f = open(json_path)
input = json.load(f)
f.close()


Jobs = input['Jobs']
n = len(Jobs)
p = np.zeros(n)
for i, J in enumerate(Jobs):
  p[i] = J['Processing']


Machines = input['Machines']
k = len(Machines)
b = [[] for i in range(k)]
w = [[] for i in range(k)]
W = [[] for i in range(k)]
m = np.zeros(k, dtype=np.int8)
for i, M in enumerate(Machines):
  sum = 0
  m[i] = len(M['Windows'])
  for t, Windown in enumerate(M['Windows']):
    b[i].append(Windown['StartTime'])
    w[i].append(Windown['Capacity'])
    W[i].append([sum, sum + w[i][t]])
    sum += w[i][t]
  b[i].append(99999)

split_min = input['Splitmin']
LB = math.ceil(np.sum(p) / k)
UB = LB + math.ceil( np.sum(m - 1) / k) * 2 * split_min


# Init
contrainst0 = []
x = {}
for i in range(n):
  x[i] = {}
  for j in range(k):
    x[i][j]  = cp.Variable(m[j], boolean = True)


y = {}
for i in range(n):
  y[i] = {}
  for j in range(k):
    y[i][j]  = cp.Variable(shape = m[j], integer=True)
    contrainst0.append(y[i][j] >= 0)

s = {}
for i in range(n):
  s[i] = {}
  for j in range(k):
    s[i][j]  = cp.Variable(shape = m[j], integer=True)
    contrainst0.append(s[i][j] >= 0)

z = cp.Variable(shape = (n,k), boolean = True)

v = {}
for i1 in range(n):
  v[i1] = {}
  for i2 in range(n):
    v[i1][i2] = {}
    for j in range(k):
      v[i1][i2][j] = cp.Variable(shape = m[j], boolean = True)

#Objective function
c = {}
for i in range(n):
  c[i] = {}
  for j in range(k):
    c[i][j] = {}
    for t in range(m[j]):
      c[i][j][t] =  y[i][j][t] + s[i][j][t]
    
C = {}
for i in range(n):
  C[i] = 0
  for j in range(k):
    for t in range(m[j]):
      C[i] = cp.maximum(C[i], c[i][j][t])

C_max = 0
for i in range(n):
  C_max = cp.maximum(C_max, C[i])

objective = cp.Minimize(C_max)

#contrainst
contrainst1 = []

for i in range(n):
  sum = 0
  for j in range(k):
    sum += cp.sum(y[i][j])

  contrainst1.append(sum == p[i])

contrainst2 = []
for j in range(k):
  for t in range(m[j]):
    sum = 0
    for i in range(n):
      sum += y[i][j][t]

    contrainst2.append(sum <= w[j][t])

contrainst3 = []
for i in range(n):
  for j in range(k):
    for t in range(m[j]):
      contrainst3.append(split_min *  x[i][j][t] <= y[i][j][t])
      contrainst3.append(y[i][j][t] <= p[i] * x[i][j][t])

contrainst4 = []
for i in range(n):
  for j in range(k):
    for t in range(m[j]):
      contrainst4.append(b[j][t] * x[i][j][t] <= s[i][j][t])
      contrainst4.append(s[i][j][t] <= b[j][t+1] - y[i][j][t])


contrainst5 = []
for i1 in range(n):
  for i2 in range(n):
    if i1 != i2:
      for j in range(k):
        for t in range(m[j]):
          contrainst5.append((c[i1][j][t]-s[i2][j][t])<=UB*v[i1][i2][j][t])
          contrainst5.append((c[i2][j][t]-s[i1][j][t])<=UB*(1-v[i1][i2][j][t]))

contrainst6 = []
for i in range(n):
    for j in range(k):
      sum = 0
      for t in range(m[j]):
        sum += x[i][j][t]

      contrainst6.append(z[i][j] <= sum)
      contrainst6.append(sum <= UB * z[i][j])

contrainst7 = []
for i in range(n):
  sum = cp.sum(z[i])
  contrainst7.append(sum == 1)

#Solve
contrainst = contrainst0 + contrainst1 + contrainst2 +contrainst3 + contrainst4  + contrainst5 + contrainst6  + contrainst7 
prob = cp.Problem(objective, contrainst)
begin = time.time()
result = prob.solve('CPLEX',cplex_params= {'timelimit': 600}, verbose=False)
result = int(result)


# Visul
print('Timer:     ', end ='')
for time in range(1,result + 1):
  print(f'{time:2d}', end = ' ')
print()
for j in range(k):
  print(f'Machine {j + 1}: ' ,end ='')
  for time in range(result):
    is_idle = True
    # print(f'{1:2d}', end = '  ')
    for t in range(m[j]):
      if W[j][t][0] <= time < W[j][t][1]:
        for i in range(n):
          if s[i][j][t].value <= time < s[i][j][t].value + y[i][j][t].value and y[i][j][t].value > 0:
            print(f'{i + 1:2d}', end = ' ')
            is_idle = False
            break
    if is_idle:
      print(f'**', end = ' ')                 
  
  print()